# План разработки модуля-синхронизатора

## Этап 1: Подготовка окружения и проектной структуры
- [ ] **Задача 1.1: Инициализировать репозиторий и структуру проекта**
  - [ ] Создать базовую директорию проекта и инициализировать репозиторий (например, с помощью `git init`)
  - [ ] Добавить начальные файлы: README.md (с описанием проекта), файл лицензии (при необходимости)
  - [ ] Определить структуру модулей: директория `synchronizer/` для кода модуля синхронизации и `app/` для основного приложения
- [ ] **Задача 1.2: Настроить Python окружение (Python 3.12+)**
  - [ ] Убедиться, что установлен Python версии 3.12 или выше
  - [ ] Создать виртуальное окружение (`python3.12 -m venv venv`) и активировать его
  - [ ] Обновить менеджер пакетов pip внутри окружения
- [ ] **Задача 1.3: Добавить зависимости проекта**
  - [ ] Установить SQLite3 (если не установлен, хотя модуль sqlite3 входит в стандартную библиотеку Python)
  - [ ] Установить библиотеку Pydantic (`pip install pydantic`)
  - [ ] Зафиксировать зависимости в файле requirements.txt
- [ ] **Задача 1.4: Проверить версию SQLite и поддержку расширений**
  - [ ] Выяснить версию SQLite в текущем окружении (`sqlite3.sqlite_version`)
  - [ ] Спланировать использование расширенной версии SQLite при необходимости (JSON1, FTS5 и др.)
- [x] **Задача 1.5: Настроить интеграцию с MT5 (локальный терминал, демо/реальный счет)**
  - [x] Установить и инициализировать MetaTrader5 для локального терминала (демо/реальный счет у AMarkets)
  - [x] Настроить авторизацию на счете (логин, пароль, сервер для демо/реального)
  - [x] Протестировать базовые операции (получение котировок, истории)
  - [x] Добавить параметры в конфиг для переключения между демо и реальным счетами
- [ ] **Задача 1.6: Настроить конфигурацию логирования (опционально)**
  - [ ] Добавить базовый файл настроек логирования (logging.yaml или logging.basicConfig)
  - [ ] Установить уровень логов (DEBUG для отладки, INFO для общего пользования)

## Этап 2: Разработка основного модуля приложения (скелет)
- [ ] **Задача 2.1: Создать основной модуль приложения для интеграции синхронизатора**
  - [ ] Создать файл `app/main.py` – точку входа приложения
  - [ ] Реализовать функцию `main()` или блок `if __name__ == "__main__":` для запуска приложения
- [ ] **Задача 2.2: Спроектировать API для взаимодействия с модулем-синхронизатором**
  - [ ] Определить способ вызова синхронизации (функция, метод класса или отдельный поток/процесс)
  - [ ] Заложить возможность передачи конфигурации в модуль синхронизатора
- [ ] **Задача 2.3: Импортировать и вызывать модуль-синхронизатор в основном модуле**
  - [ ] Добавить временную заглушку вызова синхронизатора
  - [ ] В функции `main()` вызвать синхронизатор с тестовыми параметрами
  - [ ] Запустить основной модуль для проверки отсутствия ошибок импорта
- [ ] **Задача 2.4: Обеспечить корректное завершение работы**
  - [ ] Добавить блок `try/except` в основной функции `main()` для обработки исключений
  - [ ] Убедиться в корректном выходе из программы при завершении

## Этап 3: Проектирование схемы данных и базы данных
- [ ] **Задача 3.1: Определить, какие данные будут синхронизироваться**
  - [ ] Составить список сущностей/таблиц для синхронизации
  - [ ] Определить поля и их типы для каждой сущности
- [ ] **Задача 3.2: Спроектировать схему базы данных SQLite**
  - [ ] Разработать схему таблиц SQLite с учетом ограничений целостности
  - [ ] Учесть необходимость специальных функций (JSON1, FTS5)
- [ ] **Задача 3.3: Инициализировать базу данных и таблицы**
  - [ ] Реализовать функцию `init_db()` для создания базы данных и таблиц
  - [ ] Написать SQL-скрипт для создания таблиц по спроектированной схеме
  - [ ] Протестировать инициализацию базы данных
- [ ] **Задача 3.4: Связь Pydantic-моделей с схемой БД**
  - [ ] Убедиться в соответствии полей Pydantic-моделей и схемы БД
  - [ ] Решить вопросы преобразования типов данных (например, datetime)

## Этап 4: Разработка моделей данных с использованием Pydantic
- [ ] **Задача 4.1: Определить Pydantic-модели для сущностей**
  - [ ] Создать файл `synchronizer/models.py` с классами Pydantic-моделей
  - [ ] Использовать возможности Pydantic для валидации данных
- [ ] **Задача 4.2: Реализовать преобразование между Pydantic-моделями и SQL**
  - [ ] Разработать функции преобразования моделей в формат для сохранения в БД
  - [ ] Реализовать обратное преобразование из БД в Pydantic-модели
  - [ ] Учесть особенности типов данных (datetime и др.)
- [ ] **Задача 4.3: Написать тесты для моделей (валидация)**
  - [ ] Создать модуль тестов `tests/test_models.py`
  - [ ] Проверить корректность создания моделей и валидации данных
  - [ ] Убедиться в правильности сериализации моделей

## Этап 5: Реализация логики синхронизации
- [ ] **Задача 5.1: Определить источник данных для синхронизации**
  - [ ] Решить источник данных (внешний API, файлы, другая БД)
  - [ ] Реализовать заглушку источника для тестирования
- [ ] **Задача 5.2: Разработать интерфейс модуля-синхронизатора**
  - [ ] Определить функцию или класс для запуска синхронизации
  - [ ] Спроектировать инициализацию и параметры модуля
- [ ] **Задача 5.3: Имплементация получения данных из источника**
  - [ ] Реализовать функцию `fetch_data()` для выборки данных
  - [ ] Обработать возможные ошибки источника данных
- [ ] **Задача 5.4: Имплементация обновления данных в SQLite**
  - [ ] Реализовать функцию `apply_data_to_db()` для внесения изменений в БД
  - [ ] Учесть транзакционность операций
  - [ ] Рассмотреть оптимизации для больших объемов данных
- [ ] **Задача 5.5: Управление версионностью/состоянием данных**
  - [ ] Реализовать хранение времени последней синхронизации
  - [ ] Обеспечить дельта-синхронизацию при необходимости
- [ ] **Задача 5.6: Обработка ошибок и повторные попытки**
  - [ ] Предусмотреть механизм повторных попыток при сбоях
  - [ ] Реализовать стратегии обработки конфликтов данных
  - [ ] Настроить логирование ошибок с разными уровнями
- [ ] **Задача 5.7: Интеграция с основным модулем и проверка работы**
  - [ ] Вызвать функции синхронизации из основного модуля
  - [ ] Вывести результаты работы синхронизации
  - [ ] Убедиться в корректном выполнении полного цикла синхронизации
- [ ] **Задача 5.8: Интегрировать с ChromaDB и Memgraph для векторного/графового хранения данных**
  - [ ] Добавить эмбеддинги котировок в ChromaDB (используя Ollama для текстовых представлений)
  - [ ] Строить графы в Memgraph (связи сигнал→сделка→риск)
  - [ ] Обеспечить семантический поиск и анализ связей

## Этап 6: Тестирование и отладка модульного функционала
- [ ] **Задача 6.1: Разработка модульных тестов для компонента синхронизации**
  - [ ] Написать тесты для функций получения и обновления данных
  - [ ] Проверить граничные случаи и обработку ошибок
- [ ] **Задача 6.2: Интеграционное тестирование полной цепочки**
  - [ ] Написать интеграционный тест полного процесса синхронизации
  - [ ] Проверить состояние базы данных после синхронизации
- [ ] **Задача 6.3: Тестирование отказоустойчивости**
  - [ ] Смоделировать ситуации сбоев источников данных
  - [ ] Проверить обработку конфликтных данных
  - [ ] Убедиться в откате транзакций при ошибках
- [ ] **Задача 6.4: Статический анализ и стиль кода**
  - [ ] Прогнать линтеры (flake8, black, pylint) на код
  - [ ] Исправить предупреждения по стилю и потенциальные проблемы
  - [ ] Настроить CI-процесс для автоматического контроля качества
- [ ] **Задача 6.5: Протестировать с реальными данными из MT5 (история)**
  - [ ] Использовать данные из MT5 (история терминала) для интеграционных тестов
  - [ ] Проверить синхронизацию с демо/реальным счетом
  - [ ] Валидировать корректность данных после синхронизации

## Этап 7: Документация и финальная доработка
- [ ] **Задача 7.1: Обновить документацию проекта**
  - [ ] Дополнить README.md описанием модуля-синхронизатора
  - [ ] Привести примеры запуска и настройки
  - [ ] Добавить раздел о структуре базы данных
- [ ] **Задача 7.2: Подготовить руководство по развертыванию**
  - [ ] Описать шаги запуска на новой машине
  - [ ] Упомянуть нюансы работы с SQLite
- [ ] **Задача 7.3: Финальное ревью и рефакторинг**
  - [ ] Провести обзор кода и выявить улучшения
  - [ ] Убедиться в оптимальности кода для предполагаемых объемов данных
  - [ ] Проверить прохождение всех тестов
  - [ ] Подготовить план к следующему этапу разработки

## Этап 8: Интеграция с агентами и подготовка к полному проекту ATS
- [ ] **Задача 8.1: Подготовить API для LangGraph и агентов**
  - [ ] Создать интерфейс для вызова синхронизатора из агентов (например, через функции в основном модуле)
  - [ ] Обеспечить передачу данных от синхронизатора к агентам (например, котировки для анализа)
  - [ ] Интегрировать с базовыми агентами (signal_agent_a, signal_agent_b) для тестирования сигналов
- [ ] **Задача 8.2: Тестирование интеграции с агентами**
  - [ ] Запустить синхронизатор в связке с агентами (используя мок-данные из MT5)
  - [ ] Проверить генерацию сигналов на основе синхронизированных данных
  - [ ] Валидировать динамическую адаптацию параметров (RVOL, ATR) агентами
- [ ] **Задача 8.3: Финальная подготовка к реальному времени**
  - [ ] Настроить мониторинг (логи, статус) для реального тестирования
  - [ ] Подготовить план перехода к полному проекту ATS (на основе общего плана)

## Ссылки и ресурсы
- [Pydantic: Simplifying Data Validation in Python – Real Python](https://realpython.com/python-pydantic/)
- [sqlite3 — DB-API 2.0 interface for SQLite databases — Python 3.13.7 documentation](https://docs.python.org/3/library/sqlite3.html)
