# Отчет по анализу проекта ATS

## 1. Обзор репозитория и документации
- Репозиторий описывает двухсценарную автоматизированную торговую систему (интрадей и среднесрочную), опирающуюся на многоуровневое хранение данных (SQLite, ChromaDB, Memgraph) и оркестрацию агентов через LangChain/LangGraph.【F:README.md†L1-L76】
- Детализированный план разработки разбит на восемь этапов; базовая инфраструктура и модуль синхронизации помечены как завершённые, тогда как задачи по инструментам, агентам, API и мониторингу остаются незакрытыми, что задаёт рамки для дальнейших итераций.【F:docs/project_development_plan.md†L5-L200】

## 2. Анализ текущей реализации
### 2.1 CLI и инициализация
- `src/main.py` создаёт глобальный `SyncService` при импорте модуля и повторно инициирует его в каждом CLI-вызове, что приводит к жёсткой связке CLI с конкретной реализацией сервиса и затрудняет подмену зависимостей в тестах или альтернативных сценариях запуска.【F:src/main.py†L18-L151】
- Логирование настраивается один раз при импорте и пишет в файл `ats.log`, но отсутствует управление размером/ротацией и единый формат для разных компонентов, что осложнит эксплуатационный мониторинг.【F:src/main.py†L23-L32】

### 2.2 Конфигурация
- Конфигурация через Pydantic использует глобальный синглтон `settings`, однако все параметры имеют значения по умолчанию, и отсутствуют проверки совместимости (например, что Memgraph/ChromaDB действительно доступны перед запуском синхронизации). Это усложняет обнаружение ошибок окружения на ранней стадии.【F:src/config.py†L13-L78】

### 2.3 Сервис синхронизации
- `SyncService` инициализирует базы данных как в конструкторе, так и повторно в `initialize()`, что дублирует операции и увеличивает время старта; кроме того, хранилища подтягиваются через глобальные модули `storage_module`/`vector_store_module`, делая зависимость неявной и статичной.【F:src/synchronizer/sync_service.py†L48-L134】
- Непрерывная синхронизация выполняет последовательные вызовы `sync_quotes` и `sync_trades` внутри бесконечного цикла и ждёт фиксированный интервал, не анализируя накопленные ошибки и не используя конкурентное выполнение, что может приводить к «дрейфу» времени и задержкам при увеличении числа инструментов.【F:src/synchronizer/sync_service.py†L523-L575】
- Обработчик ошибок с поддержкой повторных попыток реализован (`ErrorHandler.execute_with_retry`), но в `sync_quotes`/`sync_trades` он не задействован, из-за чего реальные сбои MT5 или хранилищ не получают автоматического ретрая и статистики ошибок.【F:src/synchronizer/utils/error_handler.py†L1-L109】【F:src/synchronizer/sync_service.py†L229-L362】

### 2.4 Слой хранения и векторное хранилище
- Хранилища SQLite открывают новое соединение на каждую операцию через `db_manager.get_connection()`, что упрощает код, но без пулов соединений и батчевой записи массовая синхронизация может стать узким местом; также логирование операций ведётся в самой же БД, что добавляет накладные расходы на каждую вставку.【F:src/database/storage.py†L1-L120】
- Векторное хранилище ChromaDB создаётся при каждом сохранении, инициализируя коллекции «на лету», но отсутствует обработка недоступности сервиса и стратегии очистки/уплотнения данных; для сигналов и индикаторов не реализованы методы чтения/поиска, что ограничивает практическую пользу эмбеддингов на следующих этапах.【F:src/database/vector_store.py†L1-L108】

### 2.5 Тесты
- Интеграционные тесты ориентированы на «живой» терминал MT5: часть сценариев ожидает реальных данных или выполняется только при доступном модуле, что усложняет автоматическое CI-тестирование и требует более явной стратегии мокирования внешних сервисов.【F:tests/integration/test_sync.py†L18-L200】

## 3. Предложения по рефакторингу и улучшениям
### Краткосрочно (до начала этапа с агентами)
- Перейти на ленивую инициализацию `SyncService` в CLI: получать экземпляр внутри каждой команды через фабрику и передавать зависимости явно (в том числе настройки и провайдеры БД), чтобы упростить тестирование и конфигурирование окружений.【F:src/main.py†L18-L200】
- Добавить защиту от повторной инициализации хранилищ в `SyncService` (флаг/контекстный менеджер) и передавать конкретные адаптеры через конструктор, устраняя глобальные модули `storage_module`/`vector_store_module` и повторные вызовы `_initialize_storages()`.【F:src/synchronizer/sync_service.py†L48-L134】
- Интегрировать `ErrorHandler.execute_with_retry` в операции получения котировок/сделок и записи в хранилища, чтобы обеспечить контролируемые повторные попытки и агрегированную статистику ошибок для мониторинга.【F:src/synchronizer/utils/error_handler.py†L64-L109】【F:src/synchronizer/sync_service.py†L229-L362】
- Расширить Pydantic-конфигурацию: добавить валидацию критичных параметров (например, обязательность путей хранения, проверку формата URI) и явные сообщения о недоступности внешних сервисов ещё до старта синхронизации.【F:src/config.py†L34-L78】

### Среднесрочно (перед реализацией агентов и API)
- Реорганизовать цикл непрерывной синхронизации: распараллелить обработку котировок и сделок через `asyncio.gather`, ввести адаптивный интервал и метрики производительности (время итерации, количество ошибок подряд).【F:src/synchronizer/sync_service.py†L523-L575】
- Оптимизировать слой хранения: сгруппировать вставки в транзакции/батчи и вынести логирование операций в отдельную очередь или асинхронный обработчик, чтобы снизить количество соединений к SQLite.【F:src/database/storage.py†L31-L82】
- Расширить векторное хранилище функциями чтения/поиска и обработкой недоступности ChromaDB, подготовив основу для последующих модулей агентов и аналитики.【F:src/database/vector_store.py†L23-L104】
- Разделить тесты на «офлайн» (полностью замоканные) и «онлайн» (с реальным MT5), добавив метки и документацию по запуску, чтобы CI мог выполнять гарантированно воспроизводимый поднабор без внешних зависимостей.【F:tests/integration/test_sync.py†L68-L200】

### Долгосрочно (совпадает с этапами 4–8 плана)
- Приступить к разработке инструментов и агентов (этап 4) только после стабилизации синхронизатора и хранилищ, чтобы новые модули опирались на устойчивую инфраструктуру данных.【F:docs/project_development_plan.md†L101-L147】
- Подготовить API-слой и оркестрацию графов в соответствии с планом этапов 5–6, используя улучшенные адаптеры хранилищ и механизмы ретрая/мониторинга из кратко- и среднесрочных задач.【F:docs/project_development_plan.md†L125-L188】
- Разработать системный мониторинг (лог-агрегация, метрики, health-check API) до запуска в боевую среду, чтобы соответствовать задачам этапов 7–8 и обеспечить наблюдаемость торговой системы.【F:docs/project_development_plan.md†L169-L200】

## 4. Рекомендованный фокус на ближайший спринт
1. Завершить укрепление синхронизатора (ленивая инициализация, ретраи, оптимизация цикла) — это снизит риски перед переходом к агентам и соответствует приоритетам этапа 3.2/3.3 из плана.【F:src/synchronizer/sync_service.py†L48-L575】【F:docs/project_development_plan.md†L75-L99】
2. Разделить тесты по окружениям и описать процедуру запуска, чтобы обеспечить воспроизводимость в CI и подготовить базу для последующего увеличения покрытия (этап 6 плана).【F:tests/integration/test_sync.py†L68-L200】【F:docs/project_development_plan.md†L149-L168】
3. После стабилизации инфраструктуры переключиться на реализацию инструментов анализа (этап 4.1) и агентов (этап 4.2), используя данные из обновлённого синхронизатора и подготовленные хранилища.【F:docs/project_development_plan.md†L101-L123】
